package core

import (
	"encoding/json"
	"fmt"
	"path"
)

type JobResource struct {
	c *Client
}

type Job struct {
	r           *JobResource
	ID          string  `json:"-"`
	Type        JobType `json:"type"`
	Data        []byte  `json:"data"`
	Status      string  `json:"status"`
	Attempts    int     `json:"attempts"`
	MaxAttempts int     `json:"max_attempts"` // this is static; config-level
	Error       string  `json:"error"`
}

type JobList struct {
	Items []*Job `json:"items"`
}

const (
	statusQueued  = "QUEUED"
	statusRunning = "RUNNING"
	statusFailed  = "FAILED"
)

// Model
//==============================================================================

// Implements OrderedModel interface
func (m *Job) SetID(id string) {
	m.ID = id
}

func (m *Job) IsQueued() bool {
	return m.Status == statusQueued
}

// Claim updates the Job status to "RUNNING" and returns nil. CompareAndSwap is
// used to prevent a race condition and ensure only one worker performs the job.
func (m *Job) Claim() error {

	fmt.Println("job calling Claim(): %#v", m)

	prev := m
	next := *m
	next.Status = statusRunning

	fmt.Println("prev", *prev)
	fmt.Println("next", next)

	return m.r.c.DB.CompareAndSwap(m.r, m.ID, prev, &next)
}

func (m *Job) RecordError(err error) error {
	fmt.Println("ERROR: ", err.Error()) // TODO

	m.Error = err.Error()
	if m.Attempts < m.MaxAttempts {
		m.Status = statusQueued // Add back to queue for retry
	} else {
		m.Status = statusFailed
	}
	m.Attempts++

	_, err = m.r.Update(m.ID, m)
	return err
}

// Resource (Collection)
//==============================================================================
func (r *JobResource) EtcdKey(id string) string {
	return path.Join("/jobs", id)
}

// InitializeModel is a part of Resource interface
func (r *JobResource) InitializeModel(m Model) {
	model := m.(*Job)
	model.r = r
}

// NOTE kinda like a New().Save()
func (r *JobResource) Start(t JobType, msg interface{}) (*Job, error) {
	data, err := json.Marshal(msg)
	if err != nil {
		return nil, err
	}

	job := &Job{
		Type:        t,
		Data:        data,
		Status:      statusQueued,
		MaxAttempts: 20, // TODO may want to expose this as an arg
	}
	return r.Create(job)
}

func (r *JobResource) List() (*JobList, error) {
	list := new(JobList)
	err := r.c.DB.ListInOrder(r, list)
	return list, err
}

func (r *JobResource) Create(m *Job) (*Job, error) {
	if err := r.c.DB.CreateInOrder(r, m); err != nil {
		return nil, err
	}
	return m, nil
}

func (r *JobResource) Get(id string) (*Job, error) {
	m := new(Job)
	err := r.c.DB.Get(r, id, m)

	// NOTE have to set ID since it is autogenerated, and the Get() method does not handle parsing keys like the other _InOrder methods do
	m.ID = id

	return m, err
}

func (r *JobResource) Update(id string, m *Job) (*Job, error) {
	err := r.c.DB.Update(r, id, m)
	return m, err
}

func (r *JobResource) Delete(id string) error {
	return r.c.DB.Delete(r, id)
}
